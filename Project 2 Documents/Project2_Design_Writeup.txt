Design Writeup


Our design choices were based on the “Project 2 High Level Design” slides provided by Professor Cerpa. Thus, from the start, we created two interfaces (with C and P modules to go along): LinkState.nc and IP.nc. We also created an LSA (Link State Advertisement) header to flood to other nodes so that each node can learn the topology. The LSA header has three structs inside it. One for the actual header contents, a struct that defines the neighbor tuple that is stored in the LSA header in an array, and our definition for neighborEntries that we previously had in NeighborDiscoveryP for Project 1. We chose to move this struct here so that the NeighborEntry can also be defined for LinkState to use.


We spent most time working on the LinkState modules, which we began with as the IP module didn’t seem like much effort to implement. We implemented Dijkstra as a helper function (although it’s actually the core of LinkState, as it arranges the shortest paths to other nodes in the topology!), and we chose to run Dijkstra to update our routing tables on a timer and when neighbors are dropped (not added). We noticed that updating the topology every single time a neighbor updates causes links to die quickly, causing our pings to fail more often than not. We also chose to use the following equations to calculate link costs:  where C is cost and Q is the link quality value (percentage multiplied by 100). Since neighbors are dropped when links are below 25, the highest possible cost for an existing direct neighbor is 16. The LinkState has two timers. One is for the first run of dijkstra which forces the interface to remain stagnant until a certain amount of time has passed to allow NeighborDiscovery to find all neighbors. The other timer runs Dijkstra again occasionally to update the topology in case any neighbors have been added or dropped. 


The IP Interface is very simple and only has two major events/commands. The first command is the send command, which, similar to flooding’s send command, starts the ping send. This only accounts for the node that starts the ping command. The LinkLayer Receive event in Ping detects if the ping is for the current node, and reacts if so. Otherwise, it takes the next hop from LinkState to the destination and forwards the message. We chose to create the forwardBuffer as a pack inside the node rather than within the scope of the event to prevent packet corruption. We also check for the protocol on the message being received and drop it if its not a protocol for us.