 1. The pros of event-driven programming are that the program is determined by events rather than a sequence of predetermined programmed instructions or code, which allows for applications to respond/interact in real time. Naturally, this means that the flow of data traffic is also dependent on events and isn’t just constantly running, meaning we get more efficient resource usage, allowing for scalability. The cons of event-driven programming are partly what make it so great; The fact that it’s driven by events means that the flow of execution is asynchronous, and while asynchronous programming provides many benefits, sometimes you may want or expect a specific order of events to happen, and that would be difficult to achieve. It also makes it difficult to trace your events from within your code because the execution order isn’t predetermined.

 2. The benefit of having both flooding checks and a TTL field is that they both prevent different possibilities that can cause an extremely inefficient broadcast within a network. If we did not have TTL checks and only had flooding checks, the flood may go way beyond our intended destination reaching the very edges of the network’s topography, or even have an infinite loop of old data that will remain on the network. If we only had TTL checks and no flooding checks, the flooding may repeat on nodes that had already received the data.

 3. When using the flooding protocol, the best case situation would be to have one flood packet per link, meaning the total amount of packets sent and received across the topography would equal the number of links. This would happen if nodes only sent packets to their neighbors that hadn’t sent them a packet. In the worst case, every node sends the flood packet to all of their neighbors, including the ones that sent them the packet. This leads to the total amount of packents being sent and received across the topography to equal twice the number of links.

4. A better way of accomplishing multi-hop communication using neighbor discovery would be to implement a combination of flooding and utilizing Dijkstra's algorithm to create a routing table, where by doing that, you create a whole map of the network, making the routing to every node very efficient. So now when a neighbor is sending a packet, it knows what neighbor to send it to because it can look up where the packet needs to go because of the routing table.

5. I think I would have kept the default packet type from Packet.h, instead of creating a whole new packet for neighbor discovery. The pros of using the default packet type is that it is more simple because the design is easier to implement and manage when there is only one packet you have to worry about. Another pro is that it reduces code complexity because you avoid handling multiple packet types. The cons of using the default packet type is that the code becomes less readable because a receiving node must first check the protocol field and then cast the generic payload to the specific nd_payload_t struct to access the neighbor discovery data.
