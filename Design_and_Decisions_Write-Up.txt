Our design choices were mostly based off of the high-level design slides shared by the professor. This led us to create 3 modules right off the start: Flooding, NeighborDiscovery, and LinkLayer. We also created a Flooding Header to store a Source Address, Sequence Number, and TTL field. 

The Link Layer we implemented processes the sending and receiving of nodes and then signals the Flooding layer (or any layer that calls it) whenever a packet is received, while telling SimpleSend to send a the packet to the next node. We chose the LinkLayer to do this full process for scalability- If we need a new module in the future to send a packet, they can call on LinkLayer as well which will send without the logic of Flooding and NeighborDiscovery. 

The Flooding module we implemented utilizes the Flooding Header we made and places it inside of the pack’s payload to give that pack the original source, sequence number to check for duplicate packets, and a TTL. This way, the packet’s other fields can be overwritten or changed while the FloodingHeader remains to keep vital information. We also added an array of structs called seen. This array, along with related functions like addSeen and alreadySeen, acts as our cache and prevents nodes from receiving a duplicate packet in flooding. We faced a lot of issues with our flooding module when it came to memory access leading to many segmentation faults and errors in the code, which led to many changes in our implementation of flooding, including the length argument in Flooding.send(). The cache and sequence number help create unique identifications for the packets if a node were to ping another node multiple times. The Flooding module uses flooding again to reply to a ping, as we hadn’t finished our lectures that would help us grasp the foundations of routing before finishing this project. 

The Neighbor Discovery module we implemented uses a periodic and randomized timer that broadcasts discovery requests to minimize collisions, and also starts with a random offset to prevent nodes from broadcasting at the same time when the network boots up. We also created a second timer inside the module that runs to check the quality of the link between two nodes or if a node even responds back to that node. If the node is not reliably responding based on the amount of time between replies or the quality of the link, then that node is dropped as a neighbor. Both these methods are implemented so that nodes that are no longer heard from are still accounted for, even when their link quality isn’t reduced. 


