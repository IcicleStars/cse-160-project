Our program for implementing a reliable transport protocol was based on the Project #3 Tips provided by Professor Cerpa, as well as his lecture slides and Chapter 5 in the Computer Networks textbook, as well as the provided Transport.nc skeleton code.  


We started off with our TCP Header, which defines a basic struct to hold vital information such as the source port, destination port, seq and ack numbers, flags, and window. This header helps the nodes identify vital information for the packet to travel and arrive reliably. After that, we created and wired our Transport modules based on the existing Transport interface, with one vital difference. There was a Transport.receive() command in the interface level, but we chose to create a Receive.receive function based on the Receive function in our IP layer module that handles the reception of packets for each node. This made it easier for us to handle the receiver-side logic, like our state machine.


Our state machine is where the logic for receiving packets occurs depending on the flag. We check flags using bitwise operations because we used a lot of bytes in creating our data and data structures, so this helps reduce the memory use of the TCP Header by using fundamental computer operations (and allows us to check for several flags with only one operation, using less memory/process). 


We designed Go-Back-N for our reliability mechanism with a 128-byte circular buffer on both the sender and receiver end. Our sender-side Sliding window is implemented throughout Transport.write, which adds data to the head of the sendBuffer via lastWritten and transmits data through our helper function try_send_next which transmits data as long as the amount of unacknowledged data is within the flow control window. Space in the buffer is freed whenever we receive an ACK through the state machine. 


The timer for the sliding window protocol was implemented using a single Timer<TMilli> component named TCPTimer to manage retransmissions based on the Go-Back-N approach. It's started by the sender (Transport.connect and Transport.write) whenever the first unacknowledged packet is sent, setting a timeout period. When a new ACK arrives, the timer is immediately restarted if there is still outstanding data, or stopped if the send window is empty. If the timer expires (TCPTimer.fired), it signals packet loss, which triggers a reset of the congestion window and a retransmission of all unacknowledged packets starting from the oldest one. We chose a fixed RTT instead of a smooth RTT because it simplifies the math that we have to do with floating point variables and calculations. In addition, it also reduces the complexity of the code due to the fact that we do not have to do any additional arithmetic.